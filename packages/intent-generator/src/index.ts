/**
 * Intent Generator â€” AI-Assisted Instrument Intent Generation
 *
 * A typed, declarative Instrument Intent Spec (IIS) generated by a constrained model.
 * Describes musical goals, not wiring.
 * References inventory by ID, never by filename.
 */

import type { InstrumentIntent } from "@msf/compiler";
import type { Inventory } from "@msf/inventory";

/**
 * Generation Prompt
 *
 * Natural language description of the desired instrument.
 */
export interface GenerationPrompt {
  /** Natural language description */
  description: string;

  /** Optional constraints */
  constraints?: {
    instrumentType?: string;
    articulations?: string[];
    noteRange?: [number, number];
    style?: string;
  };
}

/**
 * Generation Options
 */
export interface GenerationOptions {
  /** Model configuration */
  model?: {
    provider: "openai" | "anthropic" | "local";
    model: string;
    temperature?: number;
    maxTokens?: number;
  };

  /** Constraint level */
  strict?: boolean;

  /** Include examples in prompt */
  includeExamples?: boolean;
}

/**
 * Generate Instrument Intent from natural language
 *
 * Uses a constrained AI model to generate a typed Instrument Intent Spec
 * that references inventory by ID and describes musical goals.
 */
export async function generateIntent(
  prompt: GenerationPrompt,
  inventory: Inventory,
  _options: GenerationOptions = {}
): Promise<InstrumentIntent> {
  // In a real implementation, this would:
  // - Build constrained prompt with inventory context using buildConstrainedPrompt()
  // 1. Call AI model (OpenAI, Anthropic, etc.) with structured output requirements
  // 2. Parse JSON response
  // 3. Validate against InstrumentIntent schema
  // 4. Ensure all inventory references are valid IDs
  // 5. Return typed, validated intent

  // For now, generate a basic intent from available inventory
  const availableSamples = inventory.list();
  const inventoryReferences = availableSamples.slice(0, 10).map((sample: { id: string; metadata: { note?: number; velocity?: number; articulation?: string } }) => ({
    id: sample.id,
    role: "primary" as const,
    constraints: {
      noteRange: sample.metadata.note
        ? ([sample.metadata.note, sample.metadata.note] as [number, number])
        : undefined,
      velocityRange: sample.metadata.velocity
        ? ([sample.metadata.velocity, sample.metadata.velocity] as [number, number])
        : undefined,
      articulation: sample.metadata.articulation,
    },
  }));

  // Group samples by articulation
  const articulationMap = new Map<string, string[]>();
  for (const sample of availableSamples) {
    const art = sample.metadata.articulation || "default";
    const existing = articulationMap.get(art);
    if (existing) {
      existing.push(sample.id);
    } else {
      articulationMap.set(art, [sample.id]);
    }
  }

  const articulations = Array.from(articulationMap.entries()).map(
    ([name, sampleIds], idx) => ({
      id: `art_${idx}`,
      name,
      type: name,
      samples: sampleIds.slice(), // Create copy to avoid mutation
    })
  );

  const intent: InstrumentIntent = {
    intent: {
      name: prompt.constraints?.instrumentType || "Generated Instrument",
      description: prompt.description,
      instrumentType: prompt.constraints?.instrumentType || "unknown",
      targetArticulations: prompt.constraints?.articulations || Array.from(articulationMap.keys()),
    },
    inventoryReferences,
    articulations,
    mapping: {
      strategy: "chromatic",
    },
  };

  return intent;
}

/**
 * Constrain AI model output to Instrument Intent schema
 *
 * This ensures the AI generates valid, typed intent specs.
 */
export function buildConstrainedPrompt(
  prompt: GenerationPrompt,
  inventory: Inventory,
  _options: GenerationOptions = {}
): string {
  const inventoryContext = buildInventoryContext(inventory);
  const schemaDescription = buildSchemaDescription();

  return `Generate an Instrument Intent Spec for the following request:

${prompt.description}

${prompt.constraints ? `Constraints: ${JSON.stringify(prompt.constraints)}` : ""}

Available Inventory:
${inventoryContext}

Schema Requirements:
${schemaDescription}

Generate a valid JSON Instrument Intent Spec that:
1. References inventory samples by ID only (never by filename)
2. Describes musical goals, not implementation details
3. Includes all required fields
4. Uses valid articulation and mapping strategies`;
}

function buildInventoryContext(inventory: Inventory): string {
  const stats = inventory.getStats();
  const sampleList = inventory
    .list()
    .slice(0, 50) // Limit context size
    .map((entry: { id: string; metadata: { note?: number; velocity?: number; articulation?: string } }) => ({
      id: entry.id,
      note: entry.metadata.note,
      velocity: entry.metadata.velocity,
      articulation: entry.metadata.articulation,
    }));

  return JSON.stringify(
    {
      stats,
      samples: sampleList,
    },
    null,
    2
  );
}

function buildSchemaDescription(): string {
  return `
Instrument Intent Spec Schema:
- intent: { name, description, instrumentType, targetArticulations }
- inventoryReferences: [{ id, role, constraints? }]
- articulations: [{ id, name, type, samples, parameters? }]
- mapping: { strategy, zones? }
- modulation?: { sources, targets }
- performance?: { rules }
`;
}

